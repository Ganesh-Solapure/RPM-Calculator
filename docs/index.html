<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>RPM Calculator — advanced history logic (km/h default)</title>
<style>
  :root{--bg:#07121b;--card:#0b1620;--muted:#9aa6b2;--text:#e6eef6;--accent:#1f6feb}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(#051016,#07121b);color:var(--text);padding:18px}
  .wrap{max-width:1000px;margin:0 auto}
  h1{margin:0 0 8px;font-weight:600}
  .muted{color:var(--muted);font-size:0.95rem}
  .card{background:linear-gradient(#071922,#071a21);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .grid{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
  .col{flex:1 1 220px;min-width:220px}
  label{display:block;color:var(--muted);font-size:0.9rem;margin-bottom:6px}
  input,select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081018;color:var(--text);font-size:0.95rem;box-sizing:border-box}
  .controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
  button{padding:9px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .small{font-size:0.85rem;color:var(--muted)}
  pre.output{background:#07121b;border-radius:8px;padding:12px;color:var(--muted);white-space:pre-wrap}
  .computed-badge{background:#14324a;color:#bfe6ff;padding:4px 6px;border-radius:6px;font-size:0.78rem;margin-left:8px}
  .warn{color:#ffb4b4;font-weight:600;margin-top:10px}
  .hint{color:#8fb0d4;font-size:0.9rem;margin-top:8px}
  .mini{font-size:0.82rem;color:var(--muted)}
  .history { font-size:0.78rem; color:#a6d6ff; margin-left:6px; background: rgba(10,30,40,0.3); padding:2px 6px; border-radius:6px; }
  label .badge { font-size:0.7rem; margin-left:6px; color:#9aa6b2 }
  @media (max-width:720px){ .col{min-width:100%} button{width:100%} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>RPM Calculator</h1>
    <div class="muted">Enter any combination of values and press <strong>Calculate</strong>. Default speed unit is <strong>km/h</strong>.</div>
    <div class="hint">Behavior: when you edit a computed value the system will free the oldest user-provided value so it can be recalculated. In other cases the oldest computed (or user) value will be freed according to policy. Calculation runs only on pressing Calculate (or Enter).</div>

    <div class="card" style="margin-top:14px">
      <div class="grid">
        <div class="col">
          <label for="speed">Vehicle speed <span class="mini">(km/h)</span></label>
          <input id="speed" type="number" inputmode="decimal" placeholder="e.g. 100" />
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <select id="speedUnit" style="width:110px">
              <option value="kmh" selected>km/h</option>
              <option value="mph">mph</option>
            </select>
            <div class="mini">Unit</div>
          </div>
        </div>

        <div class="col">
          <label for="tire">Tire diameter (in)</label>
          <input id="tire" type="number" inputmode="decimal" placeholder="e.g. 23.0" />
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <input id="tyreCode" type="text" placeholder="Tyre code e.g. 185/55R15" style="flex:1"/>
            <button id="parseTyre" style="background:#2d4251;padding:8px 10px">Parse</button>
          </div>
        </div>

        <div class="col">
          <label for="ratio">Drivetrain transmission ratio</label>
          <input id="ratio" type="number" inputmode="decimal" placeholder="e.g. 3.99" />
        </div>

        <div class="col">
          <label for="wheel">Wheel RPM</label>
          <input id="wheel" type="number" inputmode="decimal" placeholder="e.g. 877" />
        </div>

        <div class="col">
          <label for="engine">Engine RPM</label>
          <input id="engine" type="number" inputmode="decimal" placeholder="e.g. 3500" />
        </div>
      </div>

      <div class="controls">
        <button id="calcBtn">Calculate (Enter)</button>
        <button id="clearComputed" style="background:#2b3b4a">Clear computed</button>
        <button id="resetAll" style="background:#22333b">Reset all</button>
        <div style="flex:1"></div>
        <div class="small muted">Last action: <span id="lastAction">none</span></div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;align-items:center">
        <div class="mini">User history (oldest → newest):</div>
        <div id="userHistory" class="history">none</div>
        <div class="mini" style="margin-left:12px">Computed history (oldest → newest):</div>
        <div id="computedHistory" class="history">none</div>
      </div>

      <div id="warn" class="warn" style="display:none"></div>
    </div>

    <section style="margin-top:12px">
      <h3>Output — formulas & results</h3>
      <div class="card">
        <pre id="output" class="output">Press Calculate to begin. Output will show formulas used and final numeric values.</pre>
      </div>
    </section>
  </div>

<script>
/* ============================
   Helpers & formulas
   ============================ */
const el = id => document.getElementById(id);
const toNum = v => { if (v == null) return null; const s = (''+v).trim(); if (s==='') return null; const n = Number(s); return Number.isFinite(n) ? n : null; };
const EPS = 1e-9;

const mphFrom = (value, unit) => unit === 'kmh' ? value * 0.621371 : value;
const fromMph = (mph, unit) => unit === 'kmh' ? mph / 0.621371 : mph;

function wheelsRPM_from_speed(speed_mph, tireDiaIn) { return (speed_mph * 1056) / (Math.PI * tireDiaIn); }
function speed_from_wheelsRPM(wheelsRPM, tireDiaIn){ return (wheelsRPM * Math.PI * tireDiaIn) / 1056; }
function engine_from_wheels_and_ratio(wheels, ratio){ return wheels * ratio; }
function wheels_from_engine_and_ratio(engine, ratio){ return ratio === 0 ? null : engine / ratio; }
function ratio_from_engine_and_wheels(engine, wheels){ return wheels === 0 ? null : engine / wheels; }
function tyreDiameterFromCode(code){
  const m = (code||'').trim().match(/^(\d{3})\/(\d{2})R(\d{2})$/i);
  if (!m) return null;
  const width = Number(m[1]), aspect = Number(m[2]), rim = Number(m[3]);
  const sideIn = (width * (aspect/100)) / 25.4;
  return rim + 2*sideIn;
}

/* ============================
   DOM refs & state
   ============================ */
const fields = {
  speed: el('speed'), speedUnit: el('speedUnit'),
  tire: el('tire'), tyreCode: el('tyreCode'),
  ratio: el('ratio'), wheel: el('wheel'), engine: el('engine')
};
const output = el('output'), warnEl = el('warn'), lastAction = el('lastAction');
const userHistoryEl = el('userHistory'), computedHistoryEl = el('computedHistory');

let userProvided = { speed:false, tire:false, ratio:false, wheel:false, engine:false };
let computedMarker = { speed:false, tire:false, ratio:false, wheel:false, engine:false };

// histories: oldest at index 0, newest at end
let userHistory = [];      // array of {key, ts}
let computedHistory = [];  // array of {key, ts}

/* history utilities */
function pushUserHistory(key){
  userHistory = userHistory.filter(x => x.key !== key);
  userHistory.push({key, ts: Date.now()});
  renderHistories();
}
function pushComputedHistory(key){
  computedHistory = computedHistory.filter(x => x.key !== key);
  computedHistory.push({key, ts: Date.now()});
  renderHistories();
}
function removeFromHistories(key){
  userHistory = userHistory.filter(x => x.key !== key);
  computedHistory = computedHistory.filter(x => x.key !== key);
  renderHistories();
}
function renderHistories(){
  userHistoryEl.textContent = userHistory.length ? userHistory.map(h=>h.key).join(' → ') : 'none';
  computedHistoryEl.textContent = computedHistory.length ? computedHistory.map(h=>h.key).join(' → ') : 'none';
}

/* helpers to free oldest entries */
function freeOldestUser(excludeKey=null){
  for (let i=0;i<userHistory.length;i++){
    if (userHistory[i].key === excludeKey) continue;
    const k = userHistory.splice(i,1)[0].key;
    fields[k].value = '';
    userProvided[k] = false;
    // also remove from computedMarker if any (shouldn't be user)
    computedMarker[k] = false;
    renderHistories();
    return k;
  }
  return null;
}
function freeOldestComputed(excludeKey=null){
  for (let i=0;i<computedHistory.length;i++){
    if (computedHistory[i].key === excludeKey) continue;
    const k = computedHistory.splice(i,1)[0].key;
    fields[k].value = '';
    computedMarker[k] = false;
    userProvided[k] = false;
    renderHistories();
    return k;
  }
  return null;
}
/* free oldest among both histories (choose the oldest timestamp) */
function freeOldestCombined(excludeKey=null){
  if (userHistory.length===0 && computedHistory.length===0) return null;
  // Build candidates (oldest entries)
  const candUser = userHistory.length ? userHistory[0] : null;
  const candComp = computedHistory.length ? computedHistory[0] : null;
  if (candUser && (!candComp || candUser.ts <= candComp.ts)){
    if (candUser.key === excludeKey && userHistory.length>1) {
      return freeOldestUser(excludeKey);
    } else if (candUser.key === excludeKey && userHistory.length===1) {
      // only candidate is excluded – fallback to computed
      return freeOldestComputed(excludeKey);
    } else {
      return freeOldestUser(excludeKey);
    }
  } else {
    // choose computed
    if (candComp.key === excludeKey && computedHistory.length>1) return freeOldestComputed(excludeKey);
    if (candComp.key === excludeKey && computedHistory.length===1) return freeOldestUser(excludeKey);
    return freeOldestComputed(excludeKey);
  }
}

/* ============================
   User edit policy
   ============================ */
/* Called when user types in a field (we do NOT auto-calc).
   Policy:
   - Mark field as userProvided (if not empty) and push to userHistory.
   - If the edited field was previously computed, try to free the oldest user-provided field (excluding edited). If none exist, free the oldest computed.
   - If the edited field was user-provided (i.e., changing an earlier user value), try free oldest computed first; if none, free oldest user.
   - If user clears the field, remove from userHistory / computedHistory as needed.
*/
function onUserEdit(key){
  const val = toNum(fields[key].value);
  const wasComputed = computedMarker[key];
  const previouslyUser = userProvided[key];

  // update userProvided flag
  userProvided[key] = val !== null;

  // If user provided a non-empty value now, push to userHistory
  if (val !== null) {
    pushUserHistory(key);
    // If the field was previously computed, remove its computed marker and remove from computedHistory
    if (wasComputed) {
      computedMarker[key] = false;
      computedHistory = computedHistory.filter(x=>x.key !== key);
      renderHistories();
      // Now free oldest user-provided preferentially (excluding the edited key)
      const freed = freeOldestUser(key) || freeOldestComputed(key) || null;
      if (freed) lastAction.textContent = `Freed oldest value: ${freed}`;
    } else {
      // edited a user-provided field (or changed an existing user field)
      // free oldest computed first to keep user edits favored
      const freed = freeOldestComputed(key) || freeOldestUser(key) || null;
      if (freed) lastAction.textContent = `Freed oldest value: ${freed}`;
    }
  } else {
    // user cleared the field: remove from histories and flags
    userProvided[key] = false;
    computedMarker[key] = false;
    userHistory = userHistory.filter(x=>x.key !== key);
    computedHistory = computedHistory.filter(x=>x.key !== key);
    renderHistories();
    lastAction.textContent = `Cleared ${key}`;
  }
}

/* attach listeners (no auto-calc) */
['speed','tire','ratio','wheel','engine'].forEach(k => {
  fields[k].addEventListener('input', ()=> onUserEdit(k));
});

/* tyre code parser */
el('parseTyre').addEventListener('click', ()=>{
  const code = fields.tyreCode.value.trim();
  const d = tyreDiameterFromCode(code);
  if (d === null) { alert('Tyre code not recognized — use 185/55R15'); return; }
  fields.tire.value = Number(d.toFixed(3));
  userProvided.tire = true;
  userHistory = userHistory.filter(x=>x.key !== 'tire'); // remove previous entry if any
  pushUserHistory('tire');
  // If tire was previously computed, remove from computedHistory
  computedHistory = computedHistory.filter(x=>x.key !== 'tire');
  computedMarker.tire = false;
  renderHistories();
  lastAction.textContent = 'Parsed tyre code';
});

/* ============================
   Solver (manual Calculate)
   ============================ */
function calculate(){
  // refresh flags
  userProvided.speed = toNum(fields.speed.value) !== null;
  userProvided.tire = toNum(fields.tire.value) !== null;
  userProvided.ratio = toNum(fields.ratio.value) !== null;
  userProvided.wheel = toNum(fields.wheel.value) !== null;
  userProvided.engine = toNum(fields.engine.value) !== null;

  warnEl.style.display = 'none';
  output.textContent = '';

  const raw = {
    speed_raw: toNum(fields.speed.value),
    unit: fields.speedUnit.value,
    tire: toNum(fields.tire.value),
    ratio: toNum(fields.ratio.value),
    wheel: toNum(fields.wheel.value),
    engine: toNum(fields.engine.value)
  };

  let state = {
    speed_mph: raw.speed_raw === null ? null : mphFrom(raw.speed_raw, raw.unit),
    tire: raw.tire, ratio: raw.ratio, wheel: raw.wheel, engine: raw.engine
  };

  // Steps used
  const steps = [];

  // Use iterative inference
  let changed = true, iter=0, MAX_ITER=12;
  while (changed && iter++ < MAX_ITER) {
    changed = false;

    // wheel from speed + tire
    if (state.wheel === null && state.speed_mph !== null && state.tire !== null && state.tire > EPS) {
      const val = wheelsRPM_from_speed(state.speed_mph, state.tire);
      state.wheel = val; changed = true;
      steps.push({formula:'wheel = (speed_mph × 1056) / (π × tire_in)', inputs:{speed_mph:state.speed_mph, tire_in:state.tire}, result:val});
    }

    // wheel from engine + ratio
    if (state.wheel === null && state.engine !== null && state.ratio !== null && Math.abs(state.ratio) > EPS) {
      const val = wheels_from_engine_and_ratio(state.engine, state.ratio);
      state.wheel = val; changed = true;
      steps.push({formula:'wheel = engine / ratio', inputs:{engine:state.engine, ratio:state.ratio}, result:val});
    }

    // engine from wheel + ratio
    if (state.engine === null && state.wheel !== null && state.ratio !== null) {
      const val = engine_from_wheels_and_ratio(state.wheel, state.ratio);
      state.engine = val; changed = true;
      steps.push({formula:'engine = wheel × ratio', inputs:{wheel:state.wheel, ratio:state.ratio}, result:val});
    }

    // ratio from engine + wheel
    if (state.ratio === null && state.engine !== null && state.wheel !== null && Math.abs(state.wheel) > EPS) {
      const val = ratio_from_engine_and_wheels(state.engine, state.wheel);
      state.ratio = val; changed = true;
      steps.push({formula:'ratio = engine / wheel', inputs:{engine:state.engine, wheel:state.wheel}, result:val});
    }

    // speed from wheel + tire
    if (state.speed_mph === null && state.wheel !== null && state.tire !== null) {
      const val = speed_from_wheelsRPM(state.wheel, state.tire);
      state.speed_mph = val; changed = true;
      steps.push({formula:'speed_mph = wheel × π × tire_in / 1056', inputs:{wheel:state.wheel, tire_in:state.tire}, result:val});
    }

    // tire from speed + wheel
    if (state.tire === null && state.speed_mph !== null && state.wheel !== null && Math.abs(state.wheel) > EPS) {
      const val = (state.speed_mph * 1056) / (Math.PI * state.wheel);
      state.tire = val; changed = true;
      steps.push({formula:'tire = (speed_mph × 1056) / (π × wheel)', inputs:{speed_mph:state.speed_mph, wheel:state.wheel}, result:val});
    }
  } // iterative closure

  // Conflict detection: if user provided value and computed value disagree, record conflict
  const conflicts = [];
  if (userProvided.speed && state.speed_mph !== null) {
    const userMph = mphFrom(toNum(fields.speed.value), fields.speedUnit.value);
    if (Math.abs(userMph - state.speed_mph) > 1e-6) conflicts.push('speed');
  }
  if (userProvided.tire && state.tire !== null) { if (Math.abs(toNum(fields.tire.value) - state.tire) > 1e-6) conflicts.push('tire'); }
  if (userProvided.ratio && state.ratio !== null) { if (Math.abs(toNum(fields.ratio.value) - state.ratio) > 1e-6) conflicts.push('ratio'); }
  if (userProvided.wheel && state.wheel !== null) { if (Math.abs(toNum(fields.wheel.value) - state.wheel) > 1e-6) conflicts.push('wheel'); }
  if (userProvided.engine && state.engine !== null) { if (Math.abs(toNum(fields.engine.value) - state.engine) > 1e-6) conflicts.push('engine'); }

  if (conflicts.length) {
    warnEl.style.display = 'block';
    warnEl.textContent = 'Conflicting inputs for: ' + conflicts.join(', ') + '. User-provided values are preserved.';
  } else {
    warnEl.style.display = 'none';
  }

  // Fill UI with computed values only when the field is not userProvided
  // For each computed field recorded now, push to computedHistory (update timestamp if existed)
  function fillIfFree(key, value, decimals=3){
    if (value === null || value === undefined || isNaN(value)) return;
    if (!userProvided[key]) {
      fields[key].value = Number(value).toFixed(decimals);
      computedMarker[key] = true;
      pushComputedHistory(key);
    } else {
      // ensure not marked computed
      computedMarker[key] = false;
      computedHistory = computedHistory.filter(x=>x.key !== key);
      renderHistories();
    }
  }

  if (state.speed_mph !== null) fillIfFree('speed', fromMph(state.speed_mph, fields.speedUnit.value), 3);
  fillIfFree('tire', state.tire, 3);
  fillIfFree('ratio', state.ratio, 4);
  fillIfFree('wheel', state.wheel, 3);
  fillIfFree('engine', state.engine, 2);

  // Build output text with steps and final results
  if (steps.length === 0) {
    output.textContent = 'No computations performed. Provide at least two independent values (e.g. Speed + Tire, or Wheel RPM + Ratio) and press Calculate.';
  } else {
    let txt = 'Formulas applied (in order):\n\n';
    steps.forEach((s,i) => {
      txt += `${i+1}. ${s.formula}\n`;
      Object.keys(s.inputs).forEach(k => { txt += `   • ${k}: ${Number(s.inputs[k]).toFixed(6)}\n`; });
      txt += `   => result: ${Number(s.result).toFixed(6)}\n\n`;
    });
    txt += 'Final values (display):\n';
    const dispSpeed = state.speed_mph === null ? null : Number(fromMph(state.speed_mph, fields.speedUnit.value).toFixed(6));
    txt += `  Vehicle speed (${fields.speedUnit.value}): ${dispSpeed === null ? '—' : dispSpeed}\n`;
    txt += `  Tire diameter (in): ${state.tire === null ? '—' : Number(state.tire).toFixed(6)}\n`;
    txt += `  Transmission ratio: ${state.ratio === null ? '—' : Number(state.ratio).toFixed(6)}\n`;
    txt += `  Wheel RPM: ${state.wheel === null ? '—' : Number(state.wheel).toFixed(6)}\n`;
    txt += `  Engine RPM: ${state.engine === null ? '—' : Number(state.engine).toFixed(6)}\n\n`;
    txt += 'Notes:\n - Computed fields are recorded in computed history (see badge). If you edit a computed field, the oldest user-provided value will be freed so it can be recalculated next time.\n';
    if (conflicts.length) txt += ` - Conflicts: ${conflicts.join(', ')} (user values kept)\n`;
    output.textContent = txt;
  }

  lastAction.textContent = 'Calculated';
  renderHistories();
}

/* ============================
   Buttons & bindings
   ============================ */
el('calcBtn').addEventListener('click', calculate);

el('clearComputed').addEventListener('click', ()=>{
  Object.keys(computedMarker).forEach(k => {
    if (computedMarker[k]){
      fields[k].value = '';
      computedMarker[k] = false;
    }
  });
  computedHistory = [];
  renderHistories();
  output.textContent = 'Cleared computed values.';
  lastAction.textContent = 'Cleared computed';
});

el('resetAll').addEventListener('click', ()=>{
  Object.keys(fields).forEach(k => fields[k].value = '');
  userProvided = { speed:false, tire:false, ratio:false, wheel:false, engine:false };
  computedMarker = { speed:false, tire:false, ratio:false, wheel:false, engine:false };
  userHistory = []; computedHistory = [];
  renderHistories();
  warnEl.style.display = 'none';
  output.textContent = 'Reset all fields.';
  lastAction.textContent = 'Reset all';
});

/* Enter key triggers calculate on inputs */
['speed','tire','ratio','wheel','engine','tyreCode'].forEach(id => {
  const node = fields[id] || el(id);
  if (!node) return;
  node.addEventListener('keydown', (e)=> {
    if (e.key === 'Enter') { e.preventDefault(); calculate(); }
  });
});

/* initial message */
output.textContent = 'Waiting for input. Default speed unit is km/h. Enter your values and press "Calculate".';
renderHistories();
</script>
</body>
</html>
