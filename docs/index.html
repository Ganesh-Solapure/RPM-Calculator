<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>RPM Calculator — deterministic compute (km/h default)</title>
<style>
  :root{--bg:#07121b;--card:#0b1620;--muted:#9aa6b2;--text:#e6eef6;--accent:#1f6feb}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(#051016,#07121b);color:var(--text);padding:18px}
  .wrap{max-width:1000px;margin:0 auto}
  h1{margin:0 0 8px;font-weight:600}
  .muted{color:var(--muted);font-size:0.95rem}
  .card{background:linear-gradient(#071922,#071a21);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .grid{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
  .col{flex:1 1 220px;min-width:220px}
  label{display:block;color:var(--muted);font-size:0.9rem;margin-bottom:6px}
  input,select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081018;color:var(--text);font-size:0.95rem;box-sizing:border-box}
  .controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
  button{padding:9px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .small{font-size:0.85rem;color:var(--muted)}
  pre.output{background:#07121b;border-radius:8px;padding:12px;color:var(--muted);white-space:pre-wrap}
  .computed-badge{background:#14324a;color:#bfe6ff;padding:4px 6px;border-radius:6px;font-size:0.78rem;margin-left:8px}
  .warn{color:#ffb4b4;font-weight:600;margin-top:10px}
  .hint{color:#8fb0d4;font-size:0.9rem;margin-top:8px}
  .mini{font-size:0.82rem;color:var(--muted)}
  .history { font-size:0.78rem; color:#a6d6ff; margin-left:6px; background: rgba(10,30,40,0.3); padding:2px 6px; border-radius:6px; }
  @media (max-width:720px){ .col{min-width:100%} button{width:100%} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>RPM Calculator</h1>
    <div class="muted">Enter any combination of values and press <strong>Calculate</strong>. Default speed unit is <strong>km/h</strong>.</div>
    <div class="hint">Rule summary: you can provide any subset of the 5 values (Engine RPM, Transmission ratio, Wheel RPM, Tire diameter (in), Vehicle speed). The system will compute remaining values when possible. If you edit a previously computed field, the <em>oldest computed</em> field is freed and will be recalculated on the next Calculate.</div>

    <div class="card" style="margin-top:14px">
      <div class="grid">
        <div class="col">
          <label for="speed">Vehicle speed</label>
          <input id="speed" type="number" inputmode="decimal" placeholder="e.g. 100 (km/h)" />
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <select id="speedUnit" style="width:110px">
              <option value="kmh" selected>km/h</option>
              <option value="mph">mph</option>
            </select>
            <div class="mini">Unit</div>
          </div>
        </div>

        <div class="col">
          <label for="tire">Tire diameter (in)</label>
          <input id="tire" type="number" inputmode="decimal" placeholder="e.g. 23.0" />
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <input id="tyreCode" type="text" placeholder="Tyre code e.g. 185/55R15" style="flex:1"/>
            <button id="parseTyre" style="background:#2d4251;padding:8px 10px">Parse</button>
          </div>
        </div>

        <div class="col">
          <label for="ratio">Drivetrain transmission ratio</label>
          <input id="ratio" type="number" inputmode="decimal" placeholder="e.g. 3.99" />
        </div>

        <div class="col">
          <label for="wheel">Wheel RPM</label>
          <input id="wheel" type="number" inputmode="decimal" placeholder="e.g. 877" />
        </div>

        <div class="col">
          <label for="engine">Engine RPM</label>
          <input id="engine" type="number" inputmode="decimal" placeholder="e.g. 3500" />
        </div>
      </div>

      <div class="controls">
        <button id="calcBtn">Calculate (Enter)</button>
        <button id="clearComputed" style="background:#2b3b4a">Clear computed</button>
        <button id="resetAll" style="background:#22333b">Reset all</button>
        <div style="flex:1"></div>
        <div class="small muted">Last action: <span id="lastAction">none</span></div>
      </div>

      <div style="margin-top:12px">
        <span class="mini">Computed history (oldest → newest):</span>
        <span id="computedHistory" class="mini history">none</span>
      </div>

      <div id="warn" class="warn" style="display:none"></div>
    </div>

    <section style="margin-top:12px">
      <h3>Output — formulas & results</h3>
      <div class="card">
        <pre id="output" class="output">Press Calculate to begin. Output will show formulas used and final numeric values.</pre>
      </div>
    </section>
  </div>

<script>
/* ============================
   Helper functions & formulas
   ============================ */
const el = id => document.getElementById(id);
const toNum = v => { if (v == null) return null; const s = (''+v).trim(); if (s==='') return null; const n = Number(s); return Number.isFinite(n) ? n : null; };
const NUM_TOL = 1e-9;

const mphFrom = (value, unit) => unit === 'kmh' ? value * 0.621371 : value;
const fromMph = (mph, unit) => unit === 'kmh' ? mph / 0.621371 : mph;

function wheelsRPM_from_speed(speed_mph, tireDiaIn) { return (speed_mph * 1056) / (Math.PI * tireDiaIn); }
function speed_from_wheelsRPM(wheelsRPM, tireDiaIn){ return (wheelsRPM * Math.PI * tireDiaIn) / 1056; }
function engine_from_wheels_and_ratio(wheels, ratio){ return wheels * ratio; }
function wheels_from_engine_and_ratio(engine, ratio){ return ratio === 0 ? null : engine / ratio; }
function ratio_from_engine_and_wheels(engine, wheels){ return wheels === 0 ? null : engine / wheels; }
function tyreDiameterFromCode(code){
  const m = (code||'').trim().match(/^(\d{3})\/(\d{2})R(\d{2})$/i);
  if (!m) return null;
  const width = Number(m[1]), aspect = Number(m[2]), rim = Number(m[3]);
  const sideIn = (width * (aspect/100)) / 25.4;
  return rim + 2*sideIn;
}

/* ============================
   DOM refs & state trackers
   ============================ */
const fields = {
  speed: el('speed'),
  speedUnit: el('speedUnit'),
  tire: el('tire'),
  tyreCode: el('tyreCode'),
  ratio: el('ratio'),
  wheel: el('wheel'),
  engine: el('engine')
};
const output = el('output');
const warnEl = el('warn');
const lastAction = el('lastAction');
const computedHistoryEl = el('computedHistory');

// userProvided map – set true when user filled value (not computed)
let userProvided = { speed:false, tire:false, ratio:false, wheel:false, engine:false };
// computedMarker — whether field currently has computed value
let computedMarker = { speed:false, tire:false, ratio:false, wheel:false, engine:false };

// computedHistory: array of {key: 'speed'|'tire'|..., ts:Date.now()}, oldest first
let computedHistory = [];

/* utility to update computedHistory display */
function renderComputedHistory(){
  if (computedHistory.length === 0) {
    computedHistoryEl.textContent = 'none';
    return;
  }
  computedHistoryEl.textContent = computedHistory.map((c,i)=> `${i+1}:${c.key}`).join('  →  ');
}

/* mark userProvided flags based on current non-empty fields */
function refreshUserProvidedFlags(){
  userProvided.speed = toNum(fields.speed.value) !== null;
  userProvided.tire = toNum(fields.tire.value) !== null;
  userProvided.ratio = toNum(fields.ratio.value) !== null;
  userProvided.wheel = toNum(fields.wheel.value) !== null;
  userProvided.engine = toNum(fields.engine.value) !== null;
}

/* When we compute a field (not userProvided), record it in computedHistory (newest at end) */
function recordComputed(key){
  // remove existing entry of same key if present
  computedHistory = computedHistory.filter(x=>x.key !== key);
  computedHistory.push({key, ts: Date.now()});
  computedMarker[key] = true;
  renderComputedHistory();
}

/* Remove a computed entry from history and clear its marker */
function removeComputed(key){
  computedHistory = computedHistory.filter(x=>x.key !== key);
  computedMarker[key] = false;
  renderComputedHistory();
}

/* Clear oldest computed field (oldest = computedHistory[0]) — returns key freed or null */
function freeOldestComputed(){
  if (computedHistory.length === 0) return null;
  const oldest = computedHistory.shift().key;
  // clear value in UI and clear marker
  fields[oldest].value = '';
  computedMarker[oldest] = false;
  userProvided[oldest] = false;
  renderComputedHistory();
  return oldest;
}

/* ============================
   User edit behavior
   ============================ */
/* When user edits a field:
   - mark it as userProvided if non-empty
   - if that field was previously computed (computedMarker true), FREE the oldest computed value (as per your rule)
   - do NOT auto-calc; user must press Calculate
*/
function onUserEdit(key){
  const val = toNum(fields[key].value);
  const wasComputed = computedMarker[key];
  // update userProvided flag based on value presence
  userProvided[key] = val !== null;

  if (wasComputed && val !== null) {
    // free the oldest computed: but avoid freeing the edited field itself if it's the only computed item
    if (computedHistory.length > 0) {
      // If oldest equals edited and there is more than one, free next oldest preferentially
      let freedKey = null;
      if (computedHistory[0].key === key && computedHistory.length > 1) {
        freedKey = computedHistory.splice(1,1)[0].key; // remove second item
      } else {
        freedKey = computedHistory.shift().key;
      }
      // clear freed field
      fields[freedKey].value = '';
      computedMarker[freedKey] = false;
      userProvided[freedKey] = false;
      renderComputedHistory();
      lastAction.textContent = `Freed oldest computed: ${freedKey}`;
    } else {
      // nothing to free
    }
  }

  // if user cleared value, clear userProvided and marker
  if (val === null) {
    userProvided[key] = false;
    computedMarker[key] = false;
    // also remove from computedHistory if present
    computedHistory = computedHistory.filter(x=>x.key !== key);
    renderComputedHistory();
  }
}

// attach inputs (no auto-calc)
['speed','tire','ratio','wheel','engine'].forEach(k => {
  fields[k].addEventListener('input', ()=> onUserEdit(k));
});

/* tyre code parse (fills tire and marks userProvided) */
el('parseTyre').addEventListener('click', ()=>{
  const code = fields.tyreCode.value.trim();
  const d = tyreDiameterFromCode(code);
  if (d === null) { alert('Tyre code not recognized — use 185/55R15'); return; }
  fields.tire.value = Number(d.toFixed(3));
  userProvided.tire = true;
  // clear any computed tag for tire
  computedMarker.tire = false;
  // remove from history if existed
  computedHistory = computedHistory.filter(x=>x.key !== 'tire');
  renderComputedHistory();
  lastAction.textContent = 'Parsed tyre code → tire set';
});

/* ============================
   Solver (manual Calculate)
   ============================ */
function calculate(){
  refreshUserProvidedFlags();
  warnEl.style.display = 'none';
  output.textContent = '';

  // Read current raw inputs
  const raw = {
    speed_raw: toNum(fields.speed.value),
    unit: fields.speedUnit.value,
    tire: toNum(fields.tire.value),
    ratio: toNum(fields.ratio.value),
    wheel: toNum(fields.wheel.value),
    engine: toNum(fields.engine.value)
  };

  // Convert speed to internal mph representation
  let state = {
    speed_mph: raw.speed_raw === null ? null : mphFrom(raw.speed_raw, raw.unit),
    tire: raw.tire,
    ratio: raw.ratio,
    wheel: raw.wheel,
    engine: raw.engine
  };

  // Steps to record formulas applied
  const steps = [];

  // Iteratively deduce missing values (repeat until no change or max iterations)
  let changed = true; let iter = 0; const MAX_ITER = 12;
  while (changed && iter++ < MAX_ITER) {
    changed = false;

    // Wheel from speed + tire
    if (state.wheel === null && state.speed_mph !== null && state.tire !== null && state.tire > NUM_TOL) {
      const val = wheelsRPM_from_speed(state.speed_mph, state.tire);
      state.wheel = val; changed = true;
      steps.push({formula:'wheel = (speed_mph × 1056) / (π × tire_in)', inputs:{speed_mph:state.speed_mph,tire_in:state.tire}, result:val});
    }

    // Wheel from engine + ratio
    if (state.wheel === null && state.engine !== null && state.ratio !== null && Math.abs(state.ratio) > NUM_TOL) {
      const val = wheels_from_engine_and_ratio(state.engine, state.ratio);
      state.wheel = val; changed = true;
      steps.push({formula:'wheel = engine / ratio', inputs:{engine:state.engine,ratio:state.ratio}, result:val});
    }

    // Engine from wheel + ratio
    if (state.engine === null && state.wheel !== null && state.ratio !== null) {
      const val = engine_from_wheels_and_ratio(state.wheel, state.ratio);
      state.engine = val; changed = true;
      steps.push({formula:'engine = wheel × ratio', inputs:{wheel:state.wheel,ratio:state.ratio}, result:val});
    }

    // Ratio from engine + wheel
    if (state.ratio === null && state.engine !== null && state.wheel !== null && Math.abs(state.wheel) > NUM_TOL) {
      const val = ratio_from_engine_and_wheels(state.engine, state.wheel);
      state.ratio = val; changed = true;
      steps.push({formula:'ratio = engine / wheel', inputs:{engine:state.engine,wheel:state.wheel}, result:val});
    }

    // Speed from wheel + tire
    if (state.speed_mph === null && state.wheel !== null && state.tire !== null) {
      const val = speed_from_wheelsRPM(state.wheel, state.tire);
      state.speed_mph = val; changed = true;
      steps.push({formula:'speed_mph = wheel × π × tire_in / 1056', inputs:{wheel:state.wheel,tire_in:state.tire}, result:val});
    }

    // Tire from speed + wheel
    if (state.tire === null && state.speed_mph !== null && state.wheel !== null && Math.abs(state.wheel) > NUM_TOL) {
      const val = (state.speed_mph * 1056) / (Math.PI * state.wheel);
      state.tire = val; changed = true;
      steps.push({formula:'tire = (speed_mph × 1056) / (π × wheel)', inputs:{speed_mph:state.speed_mph,wheel:state.wheel}, result:val});
    }
  } // end inference loop

  // Conflict detection: if userProvided and computed disagree, record conflict but DO NOT overwrite user value
  const conflicts = [];
  if (userProvided.speed && state.speed_mph !== null) {
    const userMph = mphFrom(toNum(fields.speed.value), fields.speedUnit.value);
    if (Math.abs(userMph - state.speed_mph) > 1e-6) conflicts.push('speed');
  }
  if (userProvided.tire && state.tire !== null) {
    if (Math.abs(toNum(fields.tire.value) - state.tire) > 1e-6) conflicts.push('tire');
  }
  if (userProvided.ratio && state.ratio !== null) {
    if (Math.abs(toNum(fields.ratio.value) - state.ratio) > 1e-6) conflicts.push('ratio');
  }
  if (userProvided.wheel && state.wheel !== null) {
    if (Math.abs(toNum(fields.wheel.value) - state.wheel) > 1e-6) conflicts.push('wheel');
  }
  if (userProvided.engine && state.engine !== null) {
    if (Math.abs(toNum(fields.engine.value) - state.engine) > 1e-6) conflicts.push('engine');
  }

  if (conflicts.length) {
    warnEl.style.display = 'block';
    warnEl.textContent = 'Conflicting inputs for: ' + conflicts.join(', ') + '. User-provided values are preserved.';
  } else {
    warnEl.style.display = 'none';
  }

  // Fill values into UI for any field that is NOT userProvided (i.e., computed)
  // For every computed field we record it in computedHistory (timestamp), update computedMarker
  function fillIfNotUser(key, value, decimals=3) {
    if (value === null || value === undefined || isNaN(value)) return;
    if (!userProvided[key]) {
      fields[key].value = Number(value).toFixed(decimals);
      computedMarker[key] = true;
      recordComputed(key); // push to computedHistory (newest)
    } else {
      // If userProvided, ensure we do not mark computed
      // but if it was previously computed remove it from history
      computedHistory = computedHistory.filter(x=>x.key !== key);
      computedMarker[key] = false;
      renderComputedHistory();
    }
  }

  if (state.speed_mph !== null) {
    const disp = fromMph(state.speed_mph, fields.speedUnit.value);
    fillIfNotUser('speed', disp, 3);
  }

  fillIfNotUser('tire', state.tire, 3);
  fillIfNotUser('ratio', state.ratio, 4);
  fillIfNotUser('wheel', state.wheel, 3);
  fillIfNotUser('engine', state.engine, 2);

  // Output formatting: formulas applied + final summary
  if (steps.length === 0) {
    output.textContent = 'No computations performed — provide at least two independent values (e.g., Speed + Tire, or Wheel RPM + Ratio), then press Calculate.';
  } else {
    let txt = 'Formulas applied (chronological):\n\n';
    steps.forEach((s, idx) => {
      txt += `${idx+1}. ${s.formula}\n`;
      Object.keys(s.inputs).forEach(k => {
        txt += `     • ${k}: ${Number(s.inputs[k]).toFixed(6)}\n`;
      });
      txt += `     => result: ${Number(s.result).toFixed(6)}\n\n`;
    });

    txt += 'Final values (display):\n';
    const dispSpeed = state.speed_mph === null ? null : Number(fromMph(state.speed_mph, fields.speedUnit.value).toFixed(6));
    txt += `  Vehicle speed (${fields.speedUnit.value}): ${dispSpeed === null ? '—' : dispSpeed}\n`;
    txt += `  Tire diameter (in): ${state.tire === null ? '—' : Number(state.tire).toFixed(6)}\n`;
    txt += `  Transmission ratio: ${state.ratio === null ? '—' : Number(state.ratio).toFixed(6)}\n`;
    txt += `  Wheel RPM: ${state.wheel === null ? '—' : Number(state.wheel).toFixed(6)}\n`;
    txt += `  Engine RPM: ${state.engine === null ? '—' : Number(state.engine).toFixed(6)}\n\n`;

    txt += 'Notes:\n';
    txt += ' - Fields marked "computed" were filled automatically (look at computed history badge).\n';
    txt += ' - If you edit a computed field, the oldest computed field will be freed (cleared) so it can be recalculated on the next Calculate.\n';
    if (conflicts.length) txt += ` - Conflicts detected for: ${conflicts.join(', ')} (user values preserved)\n`;
    output.textContent = txt;
  }

  lastAction.textContent = 'Calculated';
  renderComputedHistory();
}

/* ===============
   Buttons & keys
   =============== */
el('calcBtn').addEventListener('click', calculate);

el('clearComputed').addEventListener('click', ()=>{
  // clear only computed fields
  Object.keys(computedMarker).forEach(k=>{
    if (computedMarker[k]) {
      fields[k].value = '';
      computedMarker[k] = false;
    }
  });
  computedHistory = [];
  renderComputedHistory();
  output.textContent = 'Cleared computed values.';
  lastAction.textContent = 'Cleared computed';
});

el('resetAll').addEventListener('click', ()=>{
  Object.keys(fields).forEach(k => fields[k].value = '');
  userProvided = { speed:false, tire:false, ratio:false, wheel:false, engine:false };
  computedMarker = { speed:false, tire:false, ratio:false, wheel:false, engine:false };
  computedHistory = [];
  renderComputedHistory();
  output.textContent = 'Reset all fields.';
  lastAction.textContent = 'Reset all';
  warnEl.style.display = 'none';
});

/* Enter key to trigger calculate on inputs */
['speed','tire','ratio','wheel','engine','tyreCode'].forEach(id => {
  const node = fields[id] || el(id);
  if (!node) return;
  node.addEventListener('keydown', (e)=> {
    if (e.key === 'Enter') { e.preventDefault(); calculate(); }
  });
});

/* Initial message */
output.textContent = 'Waiting for input. Default speed unit is km/h. Enter some values then press Calculate.';
renderComputedHistory();
</script>
</body>
</html>
